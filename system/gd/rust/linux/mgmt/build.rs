use pkg_config::Config;
use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn paths_to_strs<P: AsRef<Path>>(paths: &[P]) -> Vec<&str> {
    paths.iter().map(|p| p.as_ref().as_os_str().to_str().unwrap()).collect()
}

// Generate mod.rs files for given input files.
fn gen_mod_rs<P: AsRef<Path>>(out_dir: PathBuf, inputs: &[P]) {
    // Will panic if file doesn't exist or it can't create it
    let mut f = fs::File::create(out_dir.join("mod.rs")).unwrap();

    f.write_all(b"// Generated by build.rs\n\n").unwrap();

    for i in 0..inputs.len() {
        let stem = inputs[i].as_ref().file_stem().unwrap();
        f.write_all(format!("pub mod {}; \n", stem.to_str().unwrap()).as_bytes()).unwrap();
    }
}

fn main() {
    let target_dir = std::env::var_os("CARGO_TARGET_DIR").unwrap();
    println!("cargo:rustc-link-search=native={}", target_dir.into_string().unwrap());

    // Clang requires -lc++ instead of -lstdc++
    println!("cargo:rustc-link-lib=c++");

    // When cross-compiling, pkg-config is looking for dbus at the host libdir instead of the
    // sysroot. Adding this dependency here forces the linker to include the current sysroot's
    // libdir and fixes the build issues.
    Config::new().probe("dbus-1").unwrap();
    println!("cargo:rerun-if-changed=build.rs");

    let system_api_root = PathBuf::from(std::env::var_os("CROS_SYSTEM_API_ROOT").unwrap());

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let proto_out_dir = out_dir.join("proto_out");
    let proto_input_files = [system_api_root.join("dbus/power_manager/suspend.proto")];
    let proto_include_dirs = [system_api_root.clone()];

    // Make sure to create the output directories before using it
    match fs::create_dir(proto_out_dir.as_os_str().to_str().unwrap()) {
        Err(e) => println!("Proto dir failed to be created: {}", e),
        _ => (),
    };

    protoc_rust::Codegen::new()
        .out_dir(proto_out_dir.as_os_str().to_str().unwrap())
        .inputs(&paths_to_strs(&proto_input_files))
        .includes(&paths_to_strs(&proto_include_dirs))
        .customize(Default::default())
        .run()
        .expect("Failed to run protoc");

    gen_mod_rs(proto_out_dir, &proto_input_files);
}
